'''
exploit.py

Copyright 2006 Andres Riancho

This file is part of w3af, w3af.sourceforge.net .

w3af is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation version 2 of the License.

w3af is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with w3af; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

'''

# Import w3af
import core.controllers.w3afCore
import core.controllers.outputManager as om
from core.controllers.w3afException import w3afException
import core.controllers.sessionManager as sessionManager
import core.data.kb.knowledgeBase as kb
from core.ui.consoleUi.pluginConfig import pluginConfig
from core.ui.consoleUi.consoleMenu import consoleMenu
from core.controllers.misc.exploitAll import exploitAll

class exploit(consoleMenu):
    '''
    This is the exploit configuration menu for the console.
    
    @author: Andres Riancho ( andres.riancho@gmail.com )    
    '''
    def __init__( self, w3af, commands=[] ):
        consoleMenu.__init__(self)
        self._menu = {'help':self._help, 'exploit':self._exploitWrapper,'fastexploit':self._fastexploit\
        ,'list':self._list,'back':self._back, 'interact':self._interact}
        
        self._w3af = w3af
        self._commands = commands
        
        # A list with the proxy and shell objects
        self._exploitResults = []
        
    def sh( self ):
        '''
        Starts the shell's main loop.
        
        @return: The prompt
        '''
        prompt = 'w3af/exploit>>> '
        self._mainloop( prompt )
        
    def _exec( self, command ):
        '''
        Executes a user input.
        '''
        command, parameters = self._parse( command )

        if command in self._menu.keys():
            func = self._menu[command]
            try:
                res = func(parameters)
            except KeyboardInterrupt,k:
                raise k
            return res
        else:
            om.out.console( 'command not found\n' )
            return True
        
    def _help( self, parameters ):
        '''
        Prints a help message to the user.
        '''
        if len( parameters ) == 0:
            self.mprint('The following commands are available:\n','')
            self.mprint('help','You are here. help [command] prints more specific help.')
            self.mprint('list','List available exploits.')
            self.mprint('exploit','Exploit a vulnerability found by other plugin.')
            self.mprint('fastexploit','Exploit a vulnerability based on external parameters.')
            self.mprint('back','Return to previous menu.')          

        else:
            if len( parameters ) == 1:
                if parameters[0] in self._menu.keys():
                    if parameters[0] == 'exploit':
                        om.out.console( 'Exploit a vulnerability found by audit plugins.')
                        om.out.console( 'Sintax: exploit {plugin [vulnerability-id] | * [stopOnFirst]}')
                        om.out.console( 'When using "exploit *" you will be running all exploit plugins, ordered by the probability of getting a root shell. When you add the "stopOnFirst" option to the "exploit *" command, you are making w3af stop on the first successfull exploit.')
                        om.out.console( 'Examples:')
                        om.out.console( '- exploit *')
                        om.out.console( '- exploit osCommanding')
                        om.out.console( '- exploit osCommanding 5')
                    elif parameters[0] == 'fastexploit':
                        om.out.console( 'Exploit a vulnerability based on external parameters.')
                        om.out.console( 'Sintax: fastexploit {plugin name}')
                        om.out.console( 'Example: fastexploit bsql')
                    elif parameters[0] == 'list':
                        om.out.console( 'List all available exploit plugins.')
                        om.out.console( 'Sintax: list' )
                    elif parameters[0] == 'interact':
                        om.out.console( 'List and interact with shell objects generated by exploit plugins.')
                        om.out.console( 'Sintax: interact [shell-id]' )
                        om.out.console( 'Examples: The "interact" command will list available shells and "interact 3" will start the interaction with the shell with id 3.')
                        
        return True
    
    def _exploitWrapper( self, parameters ):
        '''
        This is a simple wrapper for the _exploit method.
        '''
        try:
            self._exploit( parameters )
        except w3afException, w:
            om.out.console( str(w) )
        return True
    
    def _exploit( self , parameters, showList=True):
        '''
        Exploits a vuln.
        '''
        if not len(parameters):
            self._help(['exploit'])
        else:
            if parameters[0] == 'config':
                pConf = pluginConfig( self._w3af, self._commands )
                pluginName = parameters[1]
                prompt = 'w3af/plugin/' + pluginName + '>>> '
                try:
                    configurableObject = self._w3af.getPluginInstance( pluginName, 'attack' )
                except w3afException, e:
                    om.out.console('Error: ' + str(e) )
                else:                       
                    pConf.sh( prompt, configurableObject )
            elif parameters[0] == '*':
                if len(parameters) == 2:
                    if parameters[1] == 'stopOnFirst':
                        self._exploitAll( stopOnFirst = True )
                else:
                    self._exploitAll( stopOnFirst = False )
            else:
                # Exploit using a single plugin.
                pluginName = parameters[0]
                
                # Did the user indicated what vulnerability to exploit ?
                if len( parameters ) == 2:
                    try:
                        vulnToExploit = int(parameters[1])
                    except:
                        raise w3afException( 'You specified an invalid vulnerability id.' )
                else:
                    vulnToExploit = None
                
                if pluginName not in self._w3af.getPluginList('attack'):
                    om.out.console( 'Unknown plugin. Use the list command to view available plugins.' )
                else:
                    self._plugin = plugin = self._w3af.getPluginInstance( pluginName, 'attack' )

                    # Set the mainloop so the plugin can read from the input if it needs to, 
                    # this is used in the sql map "good samaritan" module!
                    plugin.readLoop = self._mainloop

                    try:
                        response = plugin.canExploit( vulnToExploit )
                    except w3afException, e:
                        raise e
                    else:
                        if not response:
                            raise w3afException( 'No exploitable vulnerabilities found.' )
                        else:
                            eResult = plugin.exploit( vulnToExploit )
                            if not eResult:
                                raise w3afException( 'Failed to exploit vulnerability.')
                            else:
                                self._exploitResults.extend( eResult )
                                om.out.console( 'Vulnerability successfully exploited. ' , newLine=not showList )
                                if showList:
                                    self._show()
                                    om.out.console( 'Please use the interact command to interact with the shell objects.' )
        return True

    def _interact( self, parameters ):
        '''
        Show the available shells and interact with them.
        '''
        if len(parameters) not in (0,1):
            self._help(['interact'])
        else:
            if len(parameters) == 0:
                self._show()
            else:
                try:
                    self._selectedShell = int( parameters[0] )
                except:
                    self._help(['interact'])
                else:
                    if self._selectedShell in range( len( self._exploitResults ) ):
                        prompt = self._exploitResults[ self._selectedShell ].getName()
                        
                        om.out.console( 'Execute "endInteraction" to get out of the remote shell. Commands typed in this menu will be runned on the remote web server.' )
                        prompt = 'w3af/exploit/'+prompt+'-'+str(self._selectedShell)+'>>> '
                        self._mainloop( prompt, callback = self._callback )
                    elif len(self._exploitResults) == 0:
                        om.out.console('No shell objects available; please use the exploit plugins to create them.')
                    elif len(self._exploitResults) == 1:
                        om.out.error('You can only interact with shell object with id 0; no other shells available.')
                    else:
                        om.out.error('Please select a shell in range [0-'+str(len(self._exploitResults)-1)+'].')
        
    def _show( self ):
        '''
        Show a list of available shells.
        '''
        om.out.console( 'This is a list of available shells:' )
        for e, n in zip(self._exploitResults, range(len(self._exploitResults))):
            om.out.console('- [' + str(n) + '] ' + str(e) )
        
    def _callback( self, command ):
        shell = self._exploitResults[ self._selectedShell ]
        if command == 'endInteraction':
            shell.end()
            return False
        else:
            try:
                response = shell.rexec( command )
            except w3afException, w3:
                raise
            except Exception, e:
                om.out.error('The '+ self._plugin.getName() +' plugin failed to execute the user command, exception: ' + str(e) )
                return False
            else:
                om.out.console( response )
            return True
            
    def _fastexploit( self , parameters):
        '''
        Prints a help message to the user.
        '''
        if not len( parameters ):
            om.out.console( 'Incorrect call to fastexploit, please see the help:' )
            self._help( ['fastexploit'] )
        else:
            pluginName = parameters[0]
            if pluginName not in self._w3af.getPluginList('attack'):
                om.out.console( 'Unknown plugin. Use the list command to view available plugins.' )
            else:
                self._plugin = plugin = self._w3af.getPluginInstance( pluginName, 'attack' )

                # Set the mainloop so the plugin can read from the input if it needs to, this is used in the sql map "good samaritan" module!
                self._plugin.readLoop = self._mainloop

                self._exploitResults = plugin.fastExploit()
                if not self._exploitResults:
                    raise w3afException( 'Failed to exploit vulnerability.')
                else:
                    self._showAndSelect()
                    
                    what = plugin.getAttackType()
                    if what == 'proxy':
                        om.out.console( 'Execute "exitPlugin" to get out of proxy menu. The proxy will keep running until you run "stop" inside this menu.' )
                    elif what == 'shell':
                        om.out.console( 'Execute "exitPlugin" to get out of the remote shell. Commands typed in this menu will be runned on the remote web server.' )
                    
                    prompt = 'w3af/exploit/'+pluginName+'>>> '
                    self._mainloop( prompt, callback = self._callback )
        
        return True
        
    def _list(self , parameters):
        '''
        Lists all available exploit plugins.
        '''
        list = self._w3af.getPluginList('attack')
        for plugin in list:
            desc = self._w3af.getPluginInstance( plugin, 'attack' ).getDesc()
            self.mprint( plugin, desc )
        return True
        
    def _back( self, parameters ):
        return False
    
    def _exploitAll( self, stopOnFirst = True ):
        '''
        This function creates an instance of every attack plugin, then orders it using the returning value of
        the getRootProbability method and finnaly runs every one of them until a vulnerability is successfully 
        exploited.
        
        @return: True if a vuln was successfully exploited.
        '''
        attackPluginList = self._w3af.getPluginList( 'attack' )
        #Now I create the instances...
        instanceList = []
        for pluginName in attackPluginList:
            instanceList.append( self._w3af.getPluginInstance( pluginName, 'attack' ) )
        
        # Its time to sort...
        def sortfunc(x,y):
            # reverse ordering...
            return cmp( y.getRootProbability() ,x.getRootProbability() )
        instanceList.sort( sortfunc )
        
        # Exploit !
        for ap in instanceList:
            if not ap.canExploit():
                om.out.debug('Not running plugin "' + ap.getName()  + '". The plugin is not able to exploit any of the vulnerabilities that have been found.')
            else:
                # can exploit!
                om.out.console('Using plugin: ' + ap.getName() )
                exploitedStatus = True
                try:
                    self._exploit( [ap.getName(),] , showList=False )
                except w3afException, w:
                    exploitedStatus = False
                    om.out.console( str(w) )
                else:
                    if exploitedStatus and stopOnFirst:
                        break

        if self._exploitResults:
            self._show()
            om.out.console( 'Please use the interact command to interact with the shell objects.' )
        
        return exploitedStatus
