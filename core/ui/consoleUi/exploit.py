'''
exploit.py

Copyright 2006 Andres Riancho

This file is part of w3af, w3af.sourceforge.net .

w3af is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation version 2 of the License.

w3af is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with w3af; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

'''

# Import w3af
import traceback
import core.controllers.w3afCore
import core.controllers.outputManager as om
from core.controllers.w3afException import w3afException
import core.data.kb.knowledgeBase as kb
from core.ui.consoleUi.config import *
from core.ui.consoleUi.util import *
from core.ui.consoleUi.callbackMenu import *
from core.ui.consoleUi.menu import *
from core.controllers.misc.exploitAll import exploitAll

class exploit(menu):
    '''
    This is the exploit configuration menu for the console.
    
    @author: Andres Riancho ( andres.riancho@gmail.com )    
    '''
    def __init__( self, name, console, w3af, parent=None ):
        menu.__init__(self, name, console, w3af, parent)
        
        self._configs = {}
        for pluginName in self._w3af.getPluginList( 'attack' ):
            plugin = self._w3af.getPluginInstance( pluginName, 'attack' )
            config = configMenu ( pluginName, self._console, self._w3af, self, plugin )
            self._configs[pluginName] = config
        self._loadHelp('exploit')

        # A list with the proxy and shell objects
        self._exploitResults = []
        
       
    def _exec( self, command ):
        '''
        Executes a user input.
        '''
        command, parameters = self._parse( command )

        if command in self._menu.keys():
            func = self._menu[command]
            try:
                res = func(parameters)
            except KeyboardInterrupt,k:
                raise k
            return res
        else:
            om.out.console( 'command not found\n' )
            return True
        
    def _exploitWrapper( self, parameters ):
        '''
        This is a simple wrapper for the _exploit method.
        '''
        try:
            self._exploit( parameters )
        except w3afException, w:
            om.out.console( str(w) )
        except w3afMustStopException, wmse:
            om.out.error( str(w) )
        return True
    
    def _cmd_exploit( self, params, showList=True ):
        '''
        Exploit a vuln
        '''

        if not len(params):
            self._cmd_help(['exploit'])
            return

        subcmd, params = params[0], params[1:]
        if subcmd == 'config':
            return self._configExploit( params )
        elif subcmd == '*':
            return self._exploitAll( params )
        else:
            return self._exploit( subcmd, params )

    def _para_exploit( self, params, part ):
        if len(params)==0:
            arr = ['*', 'config'] + self._configs.keys()
            return suggest(arr, part)

        if len(params)==1:
            arr=[]
            if params[0] == 'config':
                arr = self._configs.keys()
            if params[0] == '*':
                arr = ['stopOnFirst']

            return suggest(arr, part)

        return []


    def _configExploit( self, params ):
        if len( params ) == 0:
            raise w3afException( 'Plugin name was expected.')
        if len( params ) > 1:
            raise w3afException( 'Unexpected parameters: ' + ','.join(params[1:]) )

        pluginName = params[0]
        if pluginName not in self._configs:
            raise w3afException( "Unknown plugin " + pluginName)

        return self._configs[pluginName]

    def _exploitAll( self, params ):
        lp = len(params)
        stopOnFirst = len(params)>0 and params[0]=='stopOnFirst'
        maxLen = int(stopOnFirst)
        if len(params)>maxLen:
            raise w3afException( 'Unexpected parameters: ' + \
                ','.join(params[maxLen:]))

        attackPluginList = self._w3af.getPluginList( 'attack' )
        #Now I create the instances...
        instanceList = []
        for pluginName in attackPluginList:
            instanceList.append( self._w3af.getPluginInstance( pluginName, 'attack' ) )
        
        # Its time to sort...
        def sortfunc(x,y):
            # reverse ordering...
            return cmp( y.getRootProbability() ,x.getRootProbability() )
        instanceList.sort( sortfunc )
        
        # Exploit !
        for ap in instanceList:
            if not ap.canExploit():
                om.out.debug('Not running plugin "' + ap.getName()  + '". The plugin is not able to exploit any of the vulnerabilities that have been found.')
            else:
                # can exploit!
                om.out.console('Using plugin: ' + ap.getName() )
                exploitedStatus = True
                try:
                    self._exploit( [ap.getName(),] , showList=False )
                except w3afException, w:
                    exploitedStatus = False
                    om.out.console( str(w) )
                else:
                    if exploitedStatus and stopOnFirst:
                        break

        if self._exploitResults:
            self._show()
            om.out.console( 'Please use the interact command to interact with the shell objects.' )
        
        #return exploitedStatus
        
    
    def _exploit( self , pluginName, params, showList=True):
        '''
        Exploits a vuln.
        '''
        # Exploit using a single plugin.
        
        # Did the user indicated what vulnerability to exploit ?
        if len( params ) == 1:
            try:
                vulnToExploit = int(params[0])
            except:
                raise w3afException( 'You specified an invalid vulnerability id.' )
        else:
            vulnToExploit = None
        
        if pluginName not in self._configs:
            raise w3afException( 'Unknown plugin. Use the list command to view available plugins.' )
        else:
            self._plugin = plugin = self._w3af.getPluginInstance( pluginName, 'attack' )

            try:
                response = plugin.canExploit( vulnToExploit )
            except w3afException, e:
                raise e
            else:
                if not response:
                    raise w3afException( 'No exploitable vulnerabilities found.' )
                else:
                    eResult = plugin.exploit( ) #vulnToExploit )
                    if not eResult:
                        raise w3afException( 'Failed to exploit vulnerability.')
                    else:
                        # Assign a unique identifier to this shell
                        for i in range(len(self._exploitResults), len(eResult) ):
                            eResult[i].setShellId( i )

                        self._exploitResults.extend( eResult )
                        om.out.console( 'Vulnerability successfully exploited. ' , newLine=not showList )
                        if showList:
                            self._show()
                            om.out.console( 'Please use the interact command to interact with the shell objects.' )


    def _cmd_interact( self, parameters ):
        '''
        Show the available shells and interact with them.
        '''
        if len(parameters) not in (0,1):
            self._help(['interact'])
        else:
            if len(parameters) == 0:
                self._show()
            else:
                try:
                    self._selectedShell = int( parameters[0] )
                except:
                    self._help(['interact'])
                else:
                    if self._selectedShell in range( len( self._exploitResults ) ):
                        prompt = self._exploitResults[ self._selectedShell ].getName()
                        
                        om.out.console( 'Execute "endInteraction" to get out of the remote shell. Commands typed in this menu will be runned on the remote web server.' )
                        prompt = prompt+'-'+str(self._selectedShell)
                        return callbackMenu(prompt, self._console, self._w3af, self, self._callback)
#                        console = self._console.fork()
#                        console.sh( prompt, self._callback )
                    elif len(self._exploitResults) == 0:
                        om.out.console('No shell objects available; please use the exploit plugins to create them.')
                    elif len(self._exploitResults) == 1:
                        om.out.error('You can only interact with shell object with id 0; no other shells available.')
                    else:
                        om.out.error('Please select a shell in range [0-'+str(len(self._exploitResults)-1)+'].')
        
    def _show( self ):
        '''
        Show a list of available shells.
        '''
        om.out.console( 'This is a list of available shells:' )
        for e, n in zip(self._exploitResults, range(len(self._exploitResults))):
            om.out.console('- [' + str(n) + '] ' + str(e) )
        
    def _callback( self, command ):
        shell = self._exploitResults[ self._selectedShell ]
        if command == 'endInteraction':
            return self._console.back
        else:
            try:
                response = shell.rexec( command )
            except w3afException, w3:
                raise
            except Exception, e:
                om.out.error('The '+ self._plugin.getName() +' plugin failed to execute the user command, exception: ' + str(e) )
                return False
            else:
                # In some cases I just want this callback to print nothing.
                if response == None:
                    return None
                else:
                    om.out.console( response )
            return None
            
    def _cmd_fastexploit( self , parameters, showList=True):
        '''
        Prints a help message to the user.
        '''
        if not len( parameters ):
            om.out.console( 'Incorrect call to fastexploit, please see the help:' )
            self._help( ['fastexploit'] )
        else:
            pluginName = parameters[0]
            if pluginName not in self._w3af.getPluginList('attack'):
                om.out.console( 'Unknown plugin. Use the list command to view available plugins.' )
            else:
                self._plugin = plugin = self._w3af.getPluginInstance( pluginName, 'attack' )

                try:
                    eResult = plugin.fastExploit()
                except Exception, e:
#                    traceback.print_exc() # TODO
                    raise e

                # Assign a unique identifier to this shell
                for i in range(len(self._exploitResults), len(eResult) ):
                    eResult[i].setShellId( i )

                if not eResult:
                    raise w3afException( 'Failed to exploit vulnerability.')
                else:
                    self._exploitResults.extend( eResult )                    
                    om.out.console( 'Vulnerability successfully exploited. ' , newLine=not showList )
                    if showList:
                        self._show()
                        om.out.console( 'Please use the interact command to interact with the shell objects.' )
        
#        return True
        
    def _cmd_list(self , parameters):
        '''
        Lists all available exploit plugins.
        '''
        table = [['Plugin', 'Description'], []]
        for plugin in self._configs:
            desc = self._w3af.getPluginInstance( plugin, 'attack' ).getDesc()
            table.append([plugin, desc])

        self._console.drawTable(table)
        
    def _back( self, parameters ):
        return False
    
    def _exploitAll( self, stopOnFirst = True ):
        '''
        This function creates an instance of every attack plugin, then orders it using the returning value of
        the getRootProbability method and finnaly runs every one of them until a vulnerability is successfully 
        exploited.
        
        @return: True if a vuln was successfully exploited.
        '''
        attackPluginList = self._w3af.getPluginList( 'attack' )
        #Now I create the instances...
        instanceList = []
        for pluginName in attackPluginList:
            instanceList.append( self._w3af.getPluginInstance( pluginName, 'attack' ) )
        
        # Its time to sort...
        def sortfunc(x,y):
            # reverse ordering...
            return cmp( y.getRootProbability() ,x.getRootProbability() )
        instanceList.sort( sortfunc )
        
        # Exploit !
        for ap in instanceList:
            if not ap.canExploit():
                om.out.debug('Not running plugin "' + ap.getName()  + '". The plugin is not able to exploit any of the vulnerabilities that have been found.')
            else:
                # can exploit!
                om.out.console('Using plugin: ' + ap.getName() )
                exploitedStatus = True
                try:
                    self._exploit( ap.getName(), [] , showList=False )
                except w3afException, w:
                    exploitedStatus = False
                    om.out.console( str(w) )
                else:
                    if exploitedStatus and stopOnFirst:
                        break

        if self._exploitResults:
            self._show()
            om.out.console( 'Please use the interact command to interact with the shell objects.' )
        
        return exploitedStatus
