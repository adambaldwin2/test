'''
reqResViewer.py

Copyright 2008 Andres Riancho

This file is part of w3af, w3af.sourceforge.net .

w3af is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation version 2 of the License.

w3af is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with w3af; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

'''

import gtk
import gobject
import core.data.kb.knowledgeBase as kb
import core.controllers.outputManager as om
import re
from core.ui.gtkUi.entries import ValidatedEntry

useMozilla = False
useGTKHtml2 = True

try:
    import gtkmozembed
    withMozillaTab = True
except Exception, e:
    withMozillaTab = False

try:
    import gtkhtml2
    withGtkHtml2 = True
except Exception, e:
    withGtkHtml2 = False

# Signal handler to handle SIGSEGV generated by gtkhtml2
import signal
def sigsegv_handler(signum, frame):
    print 'This is a catched segmentation fault!'
    print 'I think you hitted bug #1933524 , this is mainly a gtkhtml2 problem. Please report this error here:'
    print 'https://sourceforge.net/tracker/index.php?func=detail&aid=1933524&group_id=170274&atid=853652'
signal.signal(signal.SIGSEGV, sigsegv_handler)
# End signal handler
    
class reqResViewer(gtk.HPaned):
    '''
    A VPaned with the request and the response inside.
    @author: Andres Riancho ( andres.riancho@gmail.com )
    '''
    def __init__(self, enableWidget=None):
        super(reqResViewer,self).__init__()
        
        # request
        self.request = requestPaned(enableWidget)
        self.pack1(self.request.notebook)

        # response
        self.response = responsePaned()
        self.pack2(self.response.notebook)

        self.set_position(400)
        self.show_all()


class requestResponsePaned(gtk.VPaned):
    def __init__(self, enableWidget=None):
        gtk.VPaned.__init__(self)

        # The textview where a part of the req/res is showed
        self._upTv = gtk.TextView()
        self._upTv.set_border_width(5)
        if enableWidget:
            self._upTv.get_buffer().connect("changed", self._changed, enableWidget)
            for widg in enableWidget:
                widg.set_sensitive(False)
        
        # Scroll where the textView goes
        sw1 = gtk.ScrolledWindow()
        sw1.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw1.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        
        # The textview where a part of the req/res is showed (this is for postdata and response body)
        self._downTv = gtk.TextView()
        self._downTv.set_border_width(5)
        
        # Scroll where the textView goes
        sw2 = gtk.ScrolledWindow()
        sw2.set_shadow_type(gtk.SHADOW_ETCHED_IN)
        sw2.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        
        # Add everything to the scroll views
        sw1.add(self._upTv)
        sw2.add(self._downTv)
        
        # vertical pan (allows resize of req/res texts)
        ### TODO: This should be centered
        self.set_position( 200 )
        self.pack1( sw1 )
        self.pack2( sw2 )
        self.show_all()

    def _changed(self, widg, toenable):
        '''Supervises if the widget has some text.'''
        uppBuf = self._upTv.get_buffer()
        uppText = uppBuf.get_text(uppBuf.get_start_iter(), uppBuf.get_end_iter())
        for widg in toenable:
            widg.set_sensitive(bool(uppText))
        
    def _clear( self, textView ):
        '''
        Clears a text view.
        '''
        buffer = textView.get_buffer()
        start, end = buffer.get_bounds()
        buffer.delete(start, end)
        
    def clearPanes(self):
        '''Public interface to clear both panes.'''
        self._clear( self._upTv )
        self._clear( self._downTv )

    def rawShow(self, requestresponse, body):
        '''Show the raw data.'''
        self._clear(self._upTv)
        buffer = self._upTv.get_buffer()
        iter = buffer.get_end_iter()
        buffer.insert(iter, requestresponse)
        
        self._clear(self._downTv)
        buffer = self._downTv.get_buffer()
        iter = buffer.get_end_iter()
        buffer.insert(iter, body)
        
    def getBothTexts(self):
        '''Returns the upper and lower texts.'''
        uppBuf = self._upTv.get_buffer()
        uppText = uppBuf.get_text(uppBuf.get_start_iter(), uppBuf.get_end_iter())
        lowBuf = self._downTv.get_buffer()
        lowText = lowBuf.get_text(lowBuf.get_start_iter(), lowBuf.get_end_iter())
        return (uppText, lowText)


class requestPaned(requestResponsePaned):
    def __init__(self, enableWidget=None):
        requestResponsePaned.__init__(self, enableWidget)

        self.notebook = gtk.Notebook()
        l = gtk.Label("Request")
        self.notebook.append_page(self, l)

    def show( self, method, uri, version, headers, postData ):
        '''
        Show the data in the corresponding order in self._upTv and self._downTv
        '''
        # Clear previous results
        self._clear( self._upTv )
        self._clear( self._downTv )
        
        buffer = self._upTv.get_buffer()
        iter = buffer.get_end_iter()
        buffer.insert( iter, method + ' ' + uri + ' ' + 'HTTP/' + version + '\n')
        buffer.insert( iter, headers )
        
        buffer = self._downTv.get_buffer()
        iter = buffer.get_end_iter()
        buffer.insert( iter, postData )
    
class responsePaned(requestResponsePaned):
    def __init__(self):
        requestResponsePaned.__init__(self)
        self.notebook = gtk.Notebook()

        # first page
        l = gtk.Label("Response")
        self.notebook.append_page(self, l)

        # second page, only there if html renderer available
        self._renderingWidget = None
        if (withMozillaTab and useMozilla) or (withGtkHtml2 and useGTKHtml2):
            if withGtkHtml2 and useGTKHtml2:
                renderWidget = gtkhtml2.View()
                self._renderFunction = self._renderGtkHtml2
            elif withMozillaTab and useMozilla:
                renderWidget = gtkmozembed.MozEmbed()
                self._renderFunction = self._renderMozilla
            else:
                renderWidget = None
                
            self._renderingWidget = renderWidget
            if renderWidget is not None:
                swRenderedHTML = gtk.ScrolledWindow()
                swRenderedHTML.add(renderWidget)
                self.notebook.append_page(swRenderedHTML, gtk.Label("Rendered response"))

    def _renderGtkHtml2(self, body, mimeType, baseURI):
        try:
            document = gtkhtml2.Document()
            document.clear()
            document.open_stream(mimeType)
            document.write_stream(body)
            document.close_stream()
            self._renderingWidget.set_document(document)
        except ValueError, ve:
            # I get here when the mime type is an image or something that I can't display
            pass
        except Exception, e:
            print 'This is a catched exception!'
            print 'Exception:', type(e), str(e)
            print 'I think you hitted bug #1933524 , this is mainly a gtkhtml2 problem. Please report this error here:'
            print 'https://sourceforge.net/tracker/index.php?func=detail&aid=1933524&group_id=170274&atid=853652'

    def _renderMozilla(self, body, mimeType, baseURI):
        self._renderingWidget.render_data(body, long(len(body)), baseURI , mimeType)
        

    def show( self, version, code, msg, headers, body, baseURI ):
        '''
        Show the data in the corresponding order in self._upTv and self._downTv
        '''
        # Clear previous results
        self._clear( self._upTv )
        self._clear( self._downTv )

        buffer = self._upTv.get_buffer()
        iter = buffer.get_end_iter()
        buffer.insert( iter, 'HTTP/' + version + ' ' + str(code) + ' ' + str(msg) + '\n')
        buffer.insert( iter, headers )
        
        # Get the mimeType from the response headers
        mimeType = 'text/html'
        headers = headers.split('\n')
        headers = [h for h in headers if h]
        for h in headers:
            h_name, h_value = h.split(':', 1)
            if 'content-type' in h_name.lower():
                mimeType = h_value.strip()
                break
        
        # FIXME: Show images
        if 'image' in mimeType:
            mimeType = 'text/html'
            body = 'The response type is: <i>' + mimeType + '</i>. w3af is still under development, in the future images will be displayed.'
            
        buffer = self._downTv.get_buffer()
        iter = buffer.get_end_iter()
        buffer.insert( iter, body )
        
        # Show it rendered
        if self._renderingWidget is not None:
            self._renderFunction(body, mimeType, baseURI)
