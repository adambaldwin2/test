<html>
<head>
<link rel="stylesheet" href="buzhug.css">
</head>
<body>
<table cellapadding="10" cellspacing="10">
<tr>
<td class="quickref1">Creating a database</td>
<td><i>1° Embedded mode</i>
<pre><CODE>from buzhug import Base
db = Base(path)
db.create((name1,type1)[,(name2,type2),...][,mode=cr_mode])</CODE>
</pre>
type can be str, unicode, int, float, date, datetime, another instance of Base
<p><CITE>cr_mode</CITE> can be "override" or "open". If a base already exists in the specified path, on override mode it is replaced with the new definition, if mode is "open" this base is opened
<p><i>2° Client-server mode</i>
<ol>
<li>start the server : <pre class="console">>python buzhug_server [port]</pre>
<li>create an instance of ProxyBase instead of Base
<pre><CODE>from buzhug import ProxyBase
db = ProxyBase(path<i>[,port]</i>)
</pre>
</ol>
</td>
</tr>

<tr>
<td class="quickref1">Opening an existing database</td>
<td><pre><CODE>db = Base(<i>path</i>).open()</CODE>
</pre>
</td>
</tr>

<tr>
<td class="quickref1">Closing a database</td>
<td><pre><CODE>db.close()</CODE>
</pre>
</td>
</tr>

<tr>
<td class="quickref1">Inserting a record in a database</td>
<td><pre>by keyword : <CODE>rec_id = db.insert(name1=val1[,name2=val2,...])</CODE>
    rec_id is an integer that identifies the record

by list : <CODE>db.insert(val1,val2,...)</CODE>

as strings :
    <CODE>db.insert_as_strings(name1=string1[,name2=string2,...])</CODE>
    <CODE>db.insert_as_strings(string1,string2,...)</CODE>

    For date, datetime and unicode, first specify the string format by
        <CODE>db.set_string_format(unicode,encoding)</CODE>
        <CODE>db.set_string_format(date,strftime_format)</CODE>
        <CODE>db.set_string_format(datetime,strftime_format)</CODE>
</pre>
</td>
</tr>

<tr>
<td class="quickref1">Selecting a record</td>
<td><pre>
direct access by identifier
<CODE>record = db[rec_id]</code>

list comprehension, generator expression
<code>record_set = [ record for record in db if condition ]
for record in (record for record in db if condition):
    (...do anything with record...)</code>

select() function
<code>result_set = db.select(field_list,n1=v1,n2=v2...)
result_set = db.select(field_list,n1=[min1,max1],...)
result_set = db.select(field_list,predicate_str,kw_arguments)</CODE>

If the records are selected for update, use <EM>select_for_update()</EM> instead of <EM>select()</EM>

Sorting the result :
<CODE>results = result_set.sort_by(" + field1 - field2...")</CODE>
</pre>
</td>
</tr>

<tr>
<td class="quickref1">Updating a record</td>
<td><pre><CODE>record.update(name1=newval1[,name2=newval2,...])</CODE>
</pre>
</td>
</tr>

<tr>
<td class="quickref1">Deleting records</td>
<td><pre><CODE>db.delete(record)  # delete one record
db.delete(records) # delete a list of records
del db[record_id]  # delete by record id</CODE>
</pre>
</td>
</tr>

<tr>
<td class="quickref1">Cleaning up the base</td>
<td><pre><CODE>db.cleanup()</CODE>
physically removes the deleted items from disk
</pre>
</td>
</tr>

<tr>
<td class="quickref1">External references</td>
<td><pre>A reference to a base can be used as a type in another base

<CODE>base1 = Base('base1').create((n1,t1),(n2,t2))
base2 = Base('base2').create((n3,t3),(n4,<b>base1</b>))</CODE>

Instances of base2 have attributes n4.n1 and n4.n2
</pre>
</td>
</tr>

<tr>
<td class="quickref1">Modifying the database structure</td>
<td><pre>Adding a new field : <CODE>db.add_field(field_name,field_type[,after[,default]])</CODE>

Removing a field : <CODE>db.drop_field(field_name)</CODE>
</pre>
</td>
</tr>
</table>
</body>
</html>
