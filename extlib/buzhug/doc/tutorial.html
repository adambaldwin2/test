<html>
<head>
<link rel="stylesheet" href="buzhug.css">
</head>
<body>
In this tutorial I will explain how to build and manage a database with buzhug

<h3>The example</h3>
<p>The example is a database managing information about a football championship. It will store data about the teams, the players in the teams and the matches played

<p>The base will be structured into several tables :
<table cellspacing="20">
<tr>
<td valign="top">
	<table border="1">
	<tr>
	<td class="tablename" colspan="2">teams</td>
	</tr>
	<tr>
		<td>Field name</td>
		<td>Field type</td>
	</tr>
	<tr><td>name</td><td>str</td></tr>
	<tr><td>city</td><td>str</td></tr>
	</table>
</td>
<td valign="top">
    <table border="1">
	<tr>
	<td class="tablename" colspan="2">players</td>
	</tr>
	<tr>
		<td>Field name</td>
		<td>Field type</td>
	</tr>
	<tr><td>name</td><td>unicode</td></tr>
	<tr><td>firstname</td><td>unicode</td></tr>
	<tr><td>team</td><td>teams<sup>1</sup></td></tr>
	<tr><td>position</td><td>str</td></tr>
	<tr><td>born</td><td>date</td></tr>
	</table>
</td>
<td valign="top">
	<table border="1">
	<tr>
	<td class="tablename" colspan="2">matches</td>
	</tr>
	<tr>
		<td>Field name</td>
		<td>Field type</td>
	</tr>
	<tr><td>home</td><td>teams<sup>1</sup></td></tr>
	<tr><td>away</td><td>teams<sup>1</sup></td></tr>
	<tr><td>date</td><td>date</td></tr>
	<tr><td>goals_home</td><td>int</td></tr>
	<tr><td>goals_away</td><td>int</td></tr>
	</table>
</td>
</tr>
</table>

(1) The type used for the team is a reference to a record in the first table, teams

<h3>Creating the base</h3>

<p>Here is the code to create the tables :

<pre class="python">
from buzhug import Base
from datetime import date

teams = Base('teams')
teams.create(('name',str),('city',str))

players = Base('players').create(('name',unicode),
    ('firstname',unicode),('team',teams),
    ('position',str),('born',date))
matches = Base('matches').create(('home',teams),('away',teams),
    ('date',date),('goals_home',int),('goals_away',int))
</pre>

<p>Begin by importing the class <CODE>Base</CODE> and the class <CODE>date</CODE> from the <CODE>datetime</CODE> module

<p>Then create a first instance of this class :  <CODE>teams = Base('teams')</CODE>. The argument to Base is the name of the folder where the table will be stored. I use the same name for the instance and for the folder, but you could have a different name, for instance : <CODE>teams = Base('../teams2006')</CODE>

<p>The next step is to define the structure of this table : the list of fields with their name and type, here : <CODE>teams.create(('name',str),('city',str))</CODE>. The field types are provided as Python classes, here the built-in class <CODE>str</CODE>

<p>The same goes for the two other classes, except that I use a shortcut to create the instance of the class and define its structure in one instruction (<CODE>create()</CODE> returns a reference to the instance)

<p>Save the code above in a script called <CODE>example.py</CODE> and run it ; you should have no specific message. If you take a look at the folder in which you saved the script, it should have 3 new folders called <CODE>teams, players</CODE> and <CODE>matches</CODE>, with a number of files in it, including files with the name of the fields

<p>Now try to run the same script again. You will get this exception :
<br><CODE>IOError: Base teams already exists</CODE>
<p>You are trying to create a base that already exists. To avoid this, the method <CODE>create</CODE> should be passed an extra argument, <CODE>mode</CODE>, taking the value <I>open</I> : it means that if the table already exists, it should just be opened as it is
<p>
<pre class="python">
from buzhug import Base
from datetime import date

teams = Base('teams').create(('name',str),('city',str)<B>,mode="open"</B>)
players = Base('players').create(('name',unicode),
            ('firstname',unicode),('team',teams),
            ('position',str),('born',date),
            <B>mode="open"</B>)
matches = Base('matches').create(('home',teams),('away',teams),
            ('date',date),('goals_home',int),('goals_away',int),
            <B>mode="open"</B>)
</pre>

If you knew that the table already exists, you would get a reference to it by the function <CODE>open()</CODE> :
<p>
<pre class="python">
teams = Base('teams').open()
players = Base('players').open()
matches = Base('matches').open()
</pre>

<h3>Inserting data</h3>

To insert new data in a table, you use the function insert() :
<pre class="python">
teams.insert(name="Arsenal",city="London")
teams.insert(name="Manchester United",city="Manchester")
</pre>
You can also provide the data as a list of positional arguments :
<pre class="python">
teams.insert("Chelsea","London")
teams.insert("West Bromwich Albion","Birmingham")
</pre>
<p>In this case, you <b>must</b> provide the data in the same order as what you have declared in the function create() : the name of the team first, the city afterwards

<h3>Updating a record</h3>
Suppose you made a typo when you entered the next team :
<pre class="python">
teams.insert("Aston Vila","Birmingham")
</pre>
The correct name is "Aston Villa" with two "l". If you want to fix the mistake, you have to follow these steps :
<ul>
<li>identify the record in the table
<li>update the field name with the correct value
</ul>
<p>For the first step you have to get a way of finding the correct record ; for this you must provide information that will identify the record without ambiguity. You can't ask for the record where the city is Birmingham, because there are two of them in the table ; but you can ask for the record whose name is "Aston Vila"
<p>Here is how you can find it :
<pre class="python">
aston = [ r for r in teams if r.name == "Aston Vila" ][0]
</pre>
The syntax is the one you use for Python list comprehensions : technically, the tables support the iterator protocol. When you browse the table by <CODE>for r in teams</CODE>, the items yielded are objects which have attributes called as the fields in the table, and their value is the one entered by the function <CODE>insert()</CODE>
<p>List comprehensions return a list ; here you know that there is only one record with this name, and you get a reference to it as the first and only item in the list
<p>Once you have a reference to this record, you can update its field <CODE>name</CODE> like this :
<pre class="python">
teams.update(aston,name="Aston Villa")
</pre>

<h3>More on selecting</h3>
The list comprenhension is one of the ways to select records in a base, and allows for queries as complex as you can imagine
<p>In some cases you might want to use another syntax, using the select() method :

<pre class="python">
aston = teams.select(name = "Aston Vila")[0]
</pre>

<p>You pass the function <CODE>select()</CODE> a keyword argument whose key is a field of the table, and it returns a list of records for which the field has the specified value

<p>Another way is to use the record identifier, an integer which is specific to the record. This identifier is returned when you insert the record. So if you had inserted the record about Aston Villa by :
<pre class="python">
aston_id = teams.insert("Aston Vila","Birmingham")
</pre>
<p>the quickest way to get a reference to the record would be :

<pre class="python">
aston = teams[aston_id]
</pre>

<p>In this case the table behaves like a list, indexed by record identifiers
<h3>Entering players information</h3>
Players belong to teams (for a moment...). Instead of copying the same information about the team for each record in the base players, the field <CODE>team</CODE> only holds a reference to a record in the table teams
<p>Suppose you have to enter the Aston Villa players. First you must get a reference to the record for this team, and as we have seen above you can do it with select() :
<pre class="python">aston_villa = teams.select(name="Aston Villa")[0]
</pre>
<p>Now you can use this reference when you insert the players data :
<pre class="python">
players.insert(unicode("Mellberg"),unicode("Olof"),
    aston_villa,"Defender",date(1977,9,3))
players.insert(unicode("Baros"),unicode("Milan"),
    aston_villa,"Striker",date(1981,10,28))
</pre>
<p>The records in players have an attribute <CODE>team</CODE> ; the value of this attribute is a record in the table teams. If you want to know in which city Milan Baros plays :
<pre class="python">
baros = players.select(name=unicode("Baros"))[0]
print baros.team.city
</pre>
<p>The attribute team points to a record in teams ; if you update fields in this record, the change will be visible in the attribute. For instance, if you had inserted information about Aston Villa players when there was a typo in the team name, <CODE>baros.team.name</CODE> would have returned "Aston Vila" ; after updating the team name, <CODE>baros.team.name</CODE> returns "Aston Villa"

<h3>Using record identifiers</h3>
All records have an attribute __id__ which is set internally by buzhug when the record is created, and which is never modified as long as the record exists. If you delete the record, its __id__ will not be reused for another record
<p>The record identifier is returned by insert. Let's add another player and store his id :
<pre class="python">
chelsea = teams.select(name="Chelsea")[0]
rec_id = players.insert(unicode("Makelele"),unicode("Claude"),
    chelsea,"Midfield",date(1973,2,18))
</pre>
<p>The fastest way to find a record in the base is to use its identifier :
<pre class="python">
print "Makelele was born on ",players[rec_id].born
</pre>
<p>In this case, the table behaves exactly like a list of records, indexed by record identifiers

<h3>Who plays in that team ?</h3>
Now you should guess how to get a list of the name and first names of all Aston Villa players:
<pre class="python">
print [ (r.name,r.firstname) for r in players if r.team.name == "Aston Villa" ]
</pre>
<p>Straightforward, isn't it ?

<h3>Matches</h3>
Let's now concentrate on the mutual matches of Arsenal, Aston Villa and
Chelsea and see how to produce a table of points based on these
matches.

<p>First we get a reference for Arsenal
<pre class="python">
arsenal = teams.select(name="Arsenal")[0]
</pre>

and then we can insert the matches:
<pre class="python">
matches.insert(chelsea,aston_villa,date(2005,9,24),2,1)
matches.insert(aston_villa,chelsea,date(2006,2,1),1,1)
matches.insert(chelsea,arsenal,date(2005,8,21),1,0)
matches.insert(arsenal,chelsea,date(2005,12,18),0,2)
matches.insert(arsenal,aston_villa,date(2006,4,1),5,0)
matches.insert(aston_villa,arsenal,date(2005,12,31),0,0)
</pre>
<p>Next we create a group of these teams as a list of the records for
these teams - actually, as a list of their identifiers :

<pre class="python">
group = [ t.__id__ for t in teams if t.name in ["Chelsea",
            "Aston Villa","Arsenal"] ]
</pre>

<p>Once again you can see how simple and natural the list comprehension syntax is used for this query, using the keyword <CODE>in</CODE>
<p>Then we have to see all the matches where these teams played against each other, and increment the points of each team. The result is stored in a dictionary <CODE>points</CODE>, mapping the team identifier to a number of points

<pre class="python">
points = {}
for team in group:
    points[team] = 0

for match in matches:
    if match.home.__id__ in group and match.away.__id__ in group:
        # both teams of this match are in the group
        home,away = match.home.__id__,match.away.__id__
        if match.goals_home > match.goals_away:
            points[home] += 3 # home win
        elif match.goals_home == match.goals_away:
            points[home] += 1 # draw
            points[away] += 1
        else:
            points[away] += 3 # away win
</pre>
<p>The last step is to build a table with team name and points, sort it by decreasing number of points, and finally print the table :

<pre class="python">
table = [ (teams[i].name,points[i]) for i in points.keys() ]
# sort by decreasing number of points
table.sort(lambda x,y : cmp(y[1],x[1]))
# pretty print
print '%-15s%4s' %('','Pts')
for t in table:
    print '%-15s%4s' %(t[0],t[1])
</pre>
</html>
</body>
