<html>
<head>
<link rel="stylesheet" href="buzhug.css">
</head>
<body>
The implementation of buzhug was made with a main objective : make all operations, and especially selections, as fast as possible. When a choice had to be made between different options, I took the one that optimized the speed, even if this meant more files to manage and more space used on disk
<p>This is why a base is not kept in a single file, but in a directory with many files. There are two sorts of files :
<ul>
<li>those who hold the data, the "field files" : one file per field
<li>those who are used internally by buzhug
</ul>
<h3>The field files</h3>
In the base definition, a field is defined by its name and its type. A field file is created for each of the fields, and two other field files are added by buzhug :
<ul>
<li>one for the record identifiers : field __id__
<li>one for the record version number (used for concurrency control) : field __version__
</ul>
<p>The field files store information in a different way depending on the type of the field. Field types can be split into two categories :
<ul>
<li>fixed-length types : int (in the range -2**30 +1, 2**30-1), float, links to other bases (it uses an integer)
<li>variable-length types : str, unicode ; although date and datetime are fixed-length types, they are stored as variable-length types for performance reasons
</ul>
<p>For fixed-length types, the values are stored as strings using a conversion function. Because of the way the <EM>select()</EM> method works, it is essential that this conversion function preserves the ordering of values, that is : if you have two values v1 and v2 and the conversion function is <EM>conv()</EM> then you must have :
<blockquote>if v1 > v2 then conv(v1) > conv(v2)
</blockquote>
and more generally,
<BLOCKQUOTE>
cmp(v1,v2) == cmp(conv(v1),conv(v2))
</BLOCKQUOTE>

<p>The conversion functions can be found in the methods <B>to_block()</B> and <EM>from_block()</EM> of the classes in the module buzhug_classes

<p>For variable-length files, the value is converted to a string without any line break, so that it can be stored on one line in the file. Python has a loop <CODE>for line in _file:</CODE> which is extremely fast ; I found that it is much faster to browse a file with date and datetime using this loop than reading blocks of fixed-length data with <EM>read()</EM>, this is why they are stored as variable length types

<p>For all types, the "blocks" that store a value begin with a flag which can take 3 different values :
<ul>
<li>- : means that the field is initialized to a value
<li>! : the field is not initialized, its value is None (this happens if you use <EM>insert()</EM> mithout specifying a value for this field)
<li># : means that the record has been deleted
</ul>
<h3>Internal files</h3>
The files defined for internal use are :
<ul>
<li>__info__ : stores the field definition : name and type of the fields
<li>__pos__ : the position file. It is organized in logical "rows", one row per record in the base. Like in field files, if a record is deleted, the row begins by # ; otherwise it begins by -
<br>The row is structured in 4-byte blocks, one block per field in the base (including the internal fiels __id__ and __version__), in the same order as in the base definition. The block for a field is the physical position of the value of this field in the field file
<br>For instance if the base has only one field, 'name', and you enter some names in the base, the field file name will be structured like this :
<br><center>
<table border="1">
<tr><td colspan="2"><b>Field file 'name'</b></td></tr>
<tr><td>position</td><td>value</td></tr>
<tr><td>0</td><td>-pierre\n</td></tr>
<tr><td>8</td><td>-claire\n</td></tr>
<tr><td>16</td><td>-simon\n</td></tr>
<tr><td>23</td><td>-camille\n</td></tr>
<tr><td>32</td><td>-jean\n</td></tr>
<tr><td>38</td><td>-florence\n</td></tr>
<tr><td>48</td><td>-marie-anne\n</td></tr>
</table>
</center>
<p>When records are inserted, buzhug will populate the field files __id__ and __version__ this way :
<center>
<table>
<tr>
<td>
	<table border="1">
	<tr><td colspan="2"><b>Field file '__id__'</b></td></tr>
	<tr><td>position</td><td>value (hex)</td></tr>
	<tr><td>0</td><td>2D 40 00 00 00</td></tr>
	<tr><td>5</td><td>2D 40 00 00 01</td></tr>
	<tr><td>10</td><td>2D 40 00 00 02</td></tr>
	<tr><td>15</td><td>2D 40 00 00 03</td></tr>
	<tr><td>20</td><td>2D 40 00 00 04</td></tr>
	<tr><td>25</td><td>2D 40 00 00 05</td></tr>
	<tr><td>30</td><td>2D 40 00 00 06</td></tr>
	</table>
</td>
<td>
	<table border="1">
	<tr><td colspan="2"><b>Field file '__version__'</b></td></tr>
	<tr><td>position</td><td>value (hex)</td></tr>
	<tr><td>0</td><td>2D 40 00 00 00</td></tr>
	<tr><td>5</td><td>2D 40 00 00 00</td></tr>
	<tr><td>10</td><td>2D 40 00 00 00</td></tr>
	<tr><td>15</td><td>2D 40 00 00 00</td></tr>
	<tr><td>20</td><td>2D 40 00 00 00</td></tr>
	<tr><td>25</td><td>2D 40 00 00 00</td></tr>
	<tr><td>30</td><td>2D 40 00 00 00</td></tr>
	</table>
</td>
</tr>
</table>
</center>
<p>2D is hex for the character -

<p>In the position file, the row for the record with name 'jean' will store the position of its fields __id__,__version__ and name in their respective field files, here : 20, 20, 32 (hex 14, 14, 20)
<p>These values are converted into 4-byte blocks with <CODE>struct.pack('>i',value)</CODE>, so the position file will be :
<p>
<center>
<table border="1">
<tr><td colspan="5"><b>Position file</b></td></tr>
<tr><td>position</td><td>flag</td>
<td>position in __id__ file</td>
<td>position in __version__ file</td>
<td>position in name file</td>
</tr>
<tr><td>0</td><td>2D</td><td>00 00 00 00</td><td>00 00 00 00</td><td>00 00 00 00</td></tr>
<tr><td>13</td><td>2D</td><td>00 00 00 05</td><td>00 00 00 05</td><td>00 00 00 08</td></tr>
<tr><td>26</td><td>2D</td><td>00 00 00 0A</td><td>00 00 00 0A</td><td>00 00 00 10</td></tr>
<tr><td>39</td><td>2D</td><td>00 00 00 0F</td><td>00 00 00 0F</td><td>00 00 00 17</td></tr>
<tr><td>52</td><td>2D</td><td>00 00 00 14</td><td>00 00 00 14</td><td>00 00 00 20</td></tr>
<tr><td>65</td><td>2D</td><td>00 00 00 19</td><td>00 00 00 19</td><td>00 00 00 28</td></tr>
<tr><td>78</td><td>2D</td><td>00 00 00 1E</td><td>00 00 00 1E</td><td>00 00 00 30</td></tr>
</table>
</center>
<p>
<li>_id_pos : stores a mapping between record identifiers and its row in the position file. The row is stored as a 4-byte string ; this string is at the position 5*id (always the leading 1-byte flag)
<p>It is used to access records by their id almost immediately. Lookup by id follows these steps :
<ul>
<li>compute the position in _id_pos : 5*id
<li>if the flag is set to # (deleted record) raise an IndexError
<li>otherwise read 4 bytes from position 5*id+1
<li>if <EM>read()</EM> returns an empty string, id is greater than the greatest id in the base : raise an IndexError
<li>otherwise, transform this 4-byte string into an integer : <CODE>row =  struct.unpack('>i',s)</CODE>
<li>get the position of the row in the position file : <CODE>pos = row * L</CODE> where L is the length of a row in the position file (in the example, L = 13)
<li>compute the position of the fields in their field files : for each field, get the 4-byte string holding the position, transform this string into a long integer
<li>use this position to get the data at the right place in field files
</ul>
<p>All these operations are simple and fast, so that lookup by id is itself almost immediate
<p>When a base is created and records are inserted, the values are stored sequentially in field files and in the position file ; the first inserted record has the identifier 0, the second 1 and so on. At this stage the mapping between identifiers and rows in the position file is simple
<p>Suppose you have inserted 10 records. You delete record number 3 ; the 3rd row in the position file is marked as deleted (the flag is set to #). If another record is inserted, <b>the row 3 is reused</b> for the new record ; this is done to avoid wasting useless space on disk. The new record will have id = 10 and the information stored in _id_pos for this record will be 3

<li>__del_rows__ : stores the deleted rows in field files. When a record is deleted, the flag in field files is set to # ; if it is the n-th element in the field file (n is equal for all field files) then n is stored in __del_rows__
<p>This file is used to speed up the opening of existing bases. Buzhug must keep a reference to deleted rows, and it is faster to read a file with the row numbers than to take a field file and browse all the items in it to see which ones have the flag set to #
</ul>

<h3>Deleting a record</h3>
When a record is deleted, the field files and position file are marked as deleted with the flag set to #. For instance if the record for 'jean' is deleted, here is how the field files and position file will look like :
<p>
<table>
<tr>
<td>
	<table border="1">
	<tr><td colspan="2"><b>Field file 'name'</b></td></tr>
	<tr><td>pos</td><td>value</td></tr>
	<tr><td>0</td><td>-pierre\n</td></tr>
	<tr><td>8</td><td>-claire\n</td></tr>
	<tr><td>16</td><td>-simon\n</td></tr>
	<tr><td>23</td><td>-camille\n</td></tr>
	<tr><td>32</td><td>#jean\n</td></tr>
	<tr><td>38</td><td>-florence\n</td></tr>
	<tr><td>48</td><td>-marie-anne\n</td></tr>
	</table>
</td>
<td>
	<table border="1">
	<tr><td colspan="2"><b>Field file '__id__'</b></td></tr>
	<tr><td>pos</td><td>value (hex)</td></tr>
	<tr><td>0</td><td>2D 40 00 00 00</td></tr>
	<tr><td>5</td><td>2D 40 00 00 01</td></tr>
	<tr><td>10</td><td>2D 40 00 00 02</td></tr>
	<tr><td>15</td><td>2D 40 00 00 03</td></tr>
	<tr><td>20</td><td>23 40 00 00 04</td></tr>
	<tr><td>25</td><td>2D 40 00 00 05</td></tr>
	<tr><td>30</td><td>2D 40 00 00 06</td></tr>
	</table>
</td>
<td>
	<table border="1">
	<tr><td colspan="2"><b>Field file '__version__'</b></td></tr>
	<tr><td>pos</td><td>value (hex)</td></tr>
	<tr><td>0</td><td>2D 40 00 00 00</td></tr>
	<tr><td>5</td><td>2D 40 00 00 00</td></tr>
	<tr><td>10</td><td>2D 40 00 00 00</td></tr>
	<tr><td>15</td><td>2D 40 00 00 00</td></tr>
	<tr><td>20</td><td>23 40 00 00 00</td></tr>
	<tr><td>25</td><td>2D 40 00 00 00</td></tr>
	<tr><td>30</td><td>2D 40 00 00 00</td></tr>
	</table>
</td>
<td>
	<table border="1">
	<tr><td colspan="5"><b>Position file</b></td></tr>
	<tr><td>pos</td><td>flag</td>
	<td>pos __id__</td>
	<td>pos __version__</td>
	<td>pos name</td>
	</tr>
	<tr><td>0</td><td>2D</td><td>00 00 00 00</td><td>00 00 00 00</td><td>00 00 00 00</td></tr>
	<tr><td>13</td><td>2D</td><td>00 00 00 05</td><td>00 00 00 05</td><td>00 00 00 08</td></tr>
	<tr><td>26</td><td>2D</td><td>00 00 00 0A</td><td>00 00 00 0A</td><td>00 00 00 10</td></tr>
	<tr><td>39</td><td>2D</td><td>00 00 00 0F</td><td>00 00 00 0F</td><td>00 00 00 17</td></tr>
	<tr><td>52</td><td>23</td><td>00 00 00 14</td><td>00 00 00 14</td><td>00 00 00 20</td></tr>
	<tr><td>65</td><td>2D</td><td>00 00 00 19</td><td>00 00 00 19</td><td>00 00 00 28</td></tr>
	<tr><td>78</td><td>2D</td><td>00 00 00 1E</td><td>00 00 00 1E</td><td>00 00 00 30</td></tr>
	</table>
</td>
</tr>
</table>
</center>

<p>The change is minimal (and therefore very fast) : flag '-' (hex 2D) replaced by '#' (hex 23) in 4 files
<p>The problem is that the now useless information about 'jean' remains physically on disk ; when many records have been deleted this can become a problem of memory and speed of selections
<h3>Cleanup</h3>
<p>So from time to time the method <EM>cleanup()</EM> should be applied. It removes the useless records from the field files and updates the position file to the new positions in the field files
<p>After cleanup, the files will be :
<p>
<table>
<tr>
<td valign="top">
	<table border="1">
	<tr><td colspan="2"><b>Field file 'name'</b></td></tr>
	<tr><td>pos</td><td>value</td></tr>
	<tr><td>0</td><td>-pierre\n</td></tr>
	<tr><td>8</td><td>-claire\n</td></tr>
	<tr><td>16</td><td>-simon\n</td></tr>
	<tr><td>23</td><td>-camille\n</td></tr>
	<tr><td>32</td><td>-florence\n</td></tr>
	<tr><td>42</td><td>-marie-anne\n</td></tr>
	</table>
</td>
<td valign="top">
	<table border="1">
	<tr><td colspan="2"><b>Field file '__id__'</b></td></tr>
	<tr><td>pos</td><td>value (hex)</td></tr>
	<tr><td>0</td><td>2D 40 00 00 00</td></tr>
	<tr><td>5</td><td>2D 40 00 00 01</td></tr>
	<tr><td>10</td><td>2D 40 00 00 02</td></tr>
	<tr><td>15</td><td>2D 40 00 00 03</td></tr>
	<tr><td>20</td><td>2D 40 00 00 05</td></tr>
	<tr><td>25</td><td>2D 40 00 00 06</td></tr>
	</table>
</td>
<td valign="top">
	<table border="1">
	<tr><td colspan="2"><b>Field file '__version__'</b></td></tr>
	<tr><td>pos</td><td>value (hex)</td></tr>
	<tr><td>0</td><td>2D 40 00 00 00</td></tr>
	<tr><td>5</td><td>2D 40 00 00 00</td></tr>
	<tr><td>10</td><td>2D 40 00 00 00</td></tr>
	<tr><td>15</td><td>2D 40 00 00 00</td></tr>
	<tr><td>20</td><td>2D 40 00 00 00</td></tr>
	<tr><td>25</td><td>2D 40 00 00 00</td></tr>
	</table>
</td>
<td>
	<table border="1">
	<tr><td colspan="5"><b>Position file</b></td></tr>
	<tr><td>pos</td><td>flag</td>
	<td>pos __id__</td>
	<td>pos __version__</td>
	<td>pos name</td>
	</tr>
	<tr><td>0</td><td>2D</td><td>00 00 00 00</td><td>00 00 00 00</td><td>00 00 00 00</td></tr>
	<tr><td>13</td><td>2D</td><td>00 00 00 05</td><td>00 00 00 05</td><td>00 00 00 08</td></tr>
	<tr><td>26</td><td>2D</td><td>00 00 00 0A</td><td>00 00 00 0A</td><td>00 00 00 10</td></tr>
	<tr><td>39</td><td>2D</td><td>00 00 00 0F</td><td>00 00 00 0F</td><td>00 00 00 17</td></tr>
	<tr><td>52</td><td>23</td><td>00 00 00 14</td><td>00 00 00 14</td><td>00 00 00 20</td></tr>
	<tr><td>65</td><td>2D</td><td>00 00 00 14</td><td>00 00 00 14</td><td>00 00 00 20</td></tr>
	<tr><td>78</td><td>2D</td><td>00 00 00 19</td><td>00 00 00 19</td><td>00 00 00 2A</td></tr>
	</table>
</td>
</tr>
</table>
</center>
<p>Note that the row for the deleted record is still in the position file ; it takes a useless space, but this is not a real problem because the row will be reused if another record is inserted. Also note that the file _id_pos is not modified by <EM>cleanup()</EM>, because the rows in the position file remain at the same place for a given record

<h3>Updating</h3>
When a record is updated, one of these two cases may occur :
<ul>
<li>all the modified values are fixed-length values
<li>at least one of the modified values is a variable-length value
</ul>
<p>The first case is the easiest to manage : buzhug finds the position in the field files and modifies the value at the same place ; there is no need to update the position file
<p>In the second case, the update takes place in 3 steps :
<ul>
<li>the record is deleted (the flags are set to #)
<li>the new values (with the same __id__) are inserted at the end of the field files
<li>the position file is updated to replace the previous positions in field files by the new ones
</ul>
<p>In all cases, <B>the field __version__ is modified</B> (incremented by 1). This field is used to check that, at the time when update() is called, the record stored in the base has not been modified since it was selected (which may happen if the access to the table is shared between many simultaneous users)
</body>
</html>
